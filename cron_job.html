<?php
// $Id$

/**
 * @file
 * KBOO Schedule - Episode node type
 */

module_load_include('inc', 'schedule_episode', 'schedule');

define("EPISODE_ARCHIVE_NEVER", 0);
define("EPISODE_ARCHIVE_TEMPORARY", 1);
define("EPISODE_ARCHIVE_PERMANENT", 2);

define("EPISODE_STATUS_DELETED", 0);
define("EPISODE_STATUS_SCHEDULED", 1);
define("EPISODE_STATUS_ACTIVE", 2);



/**
 * Implementation of hook_node_info().
 */
function schedule_episode_node_info() {
  return array(
    'schedule_episode' => array(
      'name' => t('Schedule Episode'),
      'module' => 'schedule_episode',
      'description' => t("Schedule entry for a show on a single calendar date."),
      'has_title' => TRUE,
      'title_label' => 'Title',
      'has_body' => TRUE,
      'body_label' => 'Description',
      'locked' => TRUE
    )
  );
}

/**
 * Implementation of hook_menu().
 */
function schedule_episode_menu() {
  $items['admin/settings/kboo'] = array(
    'title' => 'KBOO',
    'description' => t('Configure paths for the automatic stream recording'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('schedule_episode_admin_settings'),
    'access arguments' => array('configure schedule episodes'),
    'file' => 'schedule_episode.admin.inc',
  );
  $items['admin/settings/kboo/episode'] = array(
    'title' => 'Schedule Episode',
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implementation of hook_access().
 *
 * Node modules may implement node_access() to determine the operations
 * users may perform on nodes. This example uses a very common access pattern.
 */
function schedule_episode_access($op, $node, $account) {

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create schedule episode', $account);
  }

  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own schedule episode', $account) && ($account->uid == $node->uid)) {
      return TRUE;
    }
  }
}

/**
 * Implementation of hook_perm().
 *
 * Since we are limiting the ability to create new nodes to certain users,
 * we need to define what those permissions are here. We also define a permission
 * to allow users to edit the nodes they created.
 */
function schedule_episode_perm() {
  return array('create schedule episode', 'edit own schedule episode', 'configure schedule episode');
}


/**
 * Implementation of hook_validate().
 */
function schedule_episode_validate($node, &$form) {
  if($form['#post']['op'] != 'Delete'){
    $fields_info['field_schedule_date'] = content_fields('field_schedule_date');
    $db_info['field_schedule_date'] = content_database_info($fields_info['field_schedule_date']);
    //exclude current node
    $nid = ($node->nid) ? $node->nid : 0;
    $sql = "
      SELECT * FROM {node} n
      INNER JOIN {". $db_info['field_schedule_date']['table'] ."} c ON n.vid = c.vid
      WHERE n.type = 'schedule_episode'
      AND n.nid != $nid
      AND c.". $db_info['field_schedule_date']['columns']['value']['column'] ." < ". $node->field_schedule_date[0]['value2'] ."
      AND c.". $db_info['field_schedule_date']['columns']['value2']['column'] ." > ". $node->field_schedule_date[0]['value'] ."
      ORDER BY c.". $db_info['field_schedule_date']['columns']['value']['column']
      ;
    $result = db_query($sql);
    $overlapnodes = array();
    while ($overlap = db_fetch_object($result)) {
      $overlapnodes[] = l($overlap->nid, 'node/'. $overlap->nid) .": '". $overlap->title ."' (". date("g:ia", $overlap->field_schedule_date_value) ." - ". date("g:ia", $overlap->field_schedule_date_value2) .") <br />";
    }
    if (count($overlapnodes)) {
      $overtext = (count($overlapnodes) == 1) ? count($overlapnodes) ." entry" : count($overlapnodes) ." entries";
      form_set_error('', "<p>". t("This schedule episode overlaps ". $overtext .": </p><p class=\"overlap_error\">") . implode('', $overlapnodes) ."</p>");
    }
  }
}

/**
 * Implementation of hook_form().
 *
 * Now it's time to describe the form for collecting the information
 * specific to this node type. This hook requires us to return an array with
 * a sub array containing information for each element in the form.
 */
function schedule_episode_form(&$node) {

  //drupal_add_css(drupal_get_path('module', 'schedule_episode') .'/schedule_episode.css', 'module', 'screen', FALSE);

  $form['title'] = array(
    '#type' => 'textfield',
    //'#title' => check_plain($type->title_label),
    '#title' => t('Title'),
    '#description' => t("Title of the episode."),
    '#required' => TRUE,
    '#default_value' => $node->title,
    //'#weight' => -5
  );
  $form['body_filter']['body'] = array(
    '#type' => 'textarea',
    '#title' => check_plain($type->body_label),
    '#description' => t("Notes about this episode."),
    '#default_value' => $node->body,
    '#rows' => 5,
  );
  $form['body_filter']['format'] = filter_form($node->format);

  return $form;
}

/**
 * Implementation of hook_load().
 */
function schedule_episode_nodeapi(&$node, $op, $teaser, $page) {
  if ($node->type == 'schedule_episode') {
    switch ($op) {
      case 'load':
        $node->starttimestamp = $node->field_schedule_date[0]['value'];
        $node->endtimestamp = $node->field_schedule_date[0]['value2'];
        $node->starttime = _schedule_episode_secs2time($node->field_schedule_date[0]['value']);
        $node->endtime = _schedule_episode_secs2time($node->field_schedule_date[0]['value2']);
        //rjl fix short description
        $node->short_desc = $node->field_short_description[0]['value'];

        // program node info
        $prog = node_load($node->field_schedule_program[0]['nid']);
        $node->program_nid = $prog->nid;
        $node->progtitle = $prog->title;
        $node->djs = $prog->djs;

        // program date
        $node->airdate = array(
          'month' => date('n', $node->field_schedule_date[0]['value']),
          'day' => date('j', $node->field_schedule_date[0]['value']),
          'year' => date('Y', $node->field_schedule_date[0]['value'])
        );
        break;
      case 'presave':
        //if episode record state is not set, set to the program's setting. If that's not set, set to do not record.
        if(is_null($node->field_episode_record[0]['value'])){
          $program_node = node_load($node->field_schedule_program[0]['nid']);
          $node->field_episode_record[0]['value'] = (is_null($program_node->field_episode_record[0]['value'])) ? 0 : $program_node->field_episode_record[0]['value'];
        }
        break;
    }
  }
}

/**
 * create time elements from timestamp
 */
function _schedule_episode_secs2time($datestamp) {
  $day = date('m/d/Y', $datestamp);
  $hour = date('G', $datestamp);
  if ($hour > 11) {
    $hour = $hour - 12;
    $meridian = 'pm';
  }
  else {
    $meridian = 'am';
  }
  $minute = date('i', $datestamp);
  return array('day' => $day, 'hour' => $hour, 'minute' => $minute, 'meridian' => $meridian);
}

/**
 * Implementing hook_cron
 * trigger the creation of episodes from timeslots, set audio stream capture
 */
function schedule_episode_cron(){
  //pull the next 5 shows and make episodes if necessary
  $schedule_items = schedule_display_build_schedlist(time(), NULL, 6);
  //drop current item (already started);
  array_shift($schedule_items);
  foreach($schedule_items as $schedule_item){
    $node = node_load($schedule_item['nid']);
    //convert timeslots to episodes
    if($node->type == 'schedule_timeslot'){
      $new_episode = schedule_episode_create_from_timeslot($node->nid, $schedule_item['starttime'], $schedule_item['endtime']);
      $episode = node_load($new_episode);
    }
    else{
      $episode = $node;
    }
    //schedule recording if the show starts in less than 1 hour
    if($episode->starttimestamp > time() && $episode->starttimestamp < (time() + (60 * 60))){
      //see if it was queued previously
      $sql = "SELECT * FROM {kboo_schedule_episode_files} WHERE episode_id = %d";
      $prev_record = db_fetch_object(db_query($sql, $episode->nid));
      if ($prev_record == 0 || $episode->updated > $prev_record->created){
        schedule_episode_record_icecast($episode);
      }
    }
  }
  //check for recorded files to attach to episodes
  $sql = "SELECT * from {kboo_schedule_episode_files} WHERE fid IS NULL AND endtime < %d;";
  $result = db_query($sql, time());
  while($episode_audiofile = db_fetch_object($result)){
    schedule_episode_attach_audio($episode_audiofile);
  }
  //check for files that should be removed because two weeks old
  $sql = "SELECT * from {kboo_schedule_episode_files} WHERE archive = %d AND status = %d AND endtime < %d ORDER BY endtime ASC LIMIT 0, 10;";
  $result = db_query($sql, EPISODE_ARCHIVE_TEMPORARY, EPISODE_STATUS_ACTIVE, time() - (14 * 24 * 60 * 60));
  while($episode_audiofile = db_fetch_object($result)){
    schedule_episode_delete_audio($episode_audiofile);
  }
}

/**
 * Create episode from timeslot
 */
function schedule_episode_create_from_timeslot($timeslot_nid, $starttime, $endtime){
  $timeslot_node = node_load($timeslot_nid);
  $program_node = node_load($timeslot_node->field_schedule_program[0]['nid']);
  $node = new StdClass();
  $node->type = 'schedule_episode';
  $node->field_schedule_program = $timeslot_node->field_schedule_program;
  $node->field_short_description = $program_node->field_short_description;
  $node->field_site_category = $program_node->field_site_category;
  $node->taxonomy = $program_node->taxonomy;
  $node->field_schedule_date[0] = array('value' => $starttime, 'value2' => $endtime);
  //old programs might not have this set; default to 0 (do not record)
  $node->field_episode_record[0]['value'] = (is_null($program_node->field_episode_record[0]['value'])) ? 0 : $program_node->field_episode_record[0]['value'];
  $node->uid = 1;
  $node->status = 1;
  $node->active = 1;
  $node->promote = 0;
  //auto_nodetitle seems to have a bug saving these entries so apply manually
  $node->auto_nodetitle_applied = TRUE;
  $node->title = $program_node->title .' on '. date('m/d/y', $starttime);
  node_save($node);
  watchdog("schedule_episode", "Created episode node %nid: %title", array('%nid' => $node->nid, '%title' => $node->title), WATCHDOG_INFO);
  return $node->nid;
}

/**
 * Set streamripper to record episodes
 */
function schedule_episode_record_icecast($episode){
  if($episode->field_episode_record[0]['value'] != EPISODE_ARCHIVE_NEVER){
    /* streamripper options
      -l : length in seconds
      -a filename : rip to single file; timestamp if no filename
      -A don't write individual tracks
      -q : add sequence number
      -s : don't create stream dir
      -d directory : destination dir
      --quiet : no output
    */
    $ripper = variable_get('schedule_episode_streamripper', '/usr/bin/streamripper');
    $fileroot = "kboo_episode.". $episode->field_episode_record[0]['value'] .'.'. date("ymd.Hi", $episode->starttimestamp) .'.'. $episode->field_schedule_program[0]['nid'];
    //start one minute early
    $padding = 60;
    $starttime = $episode->starttimestamp - $padding;
    $length = $episode->endtimestamp + $padding - $starttime;
    $attime = date('H:i', $starttime);
    $stream = variable_get('schedule_episode_record_stream', 'http://listen.kboo.fm:8000/high.m3u');
    $record_dir = variable_get('schedule_episode_record_source', '/tmp');
    if(file_check_directory($record_dir, $mode = FILE_CREATE_DIRECTORY)){
      //must be at least five hours
      if($episode->field_episode_record[0]['value'] == EPISODE_ARCHIVE_TEMPORARY && $length < ((5 * 3600) + ($padding * 2))){
        $length = (5 * 3600) + ($padding * 2);
      }
      //use at command to schedule streamripper
      $command = "echo \"$ripper {$stream} -l {$length} -A -a {$fileroot}.mp3 -q -s -d {$record_dir} --quiet; rm {$record_dir}/{$fileroot}.cue\" | at {$attime}";
      shell_exec($command);
      watchdog("schedule_episode", "Executed: %command", array('%command' => $command), WATCHDOG_INFO);
      //add entry to db
      $sql = "INSERT INTO {kboo_schedule_episode_files}
              (episode_id, filename, filepath, archive, starttime, endtime, created, updated, status)
              VALUES (%d, '%s', '%s', %d, %d, %d, %d, %d, %d);";

      db_query($sql, $episode->nid, $fileroot .'.mp3', $record_dir, $episode->field_episode_record[0]['value'], $starttime, $starttime + $length, time(), time(), EPISODE_STATUS_SCHEDULED);
      // POST to our app with relevant info
    }
    else{
      watchdog("schedule_episode", "Cannot write to recording source path. Could not execute: %command", array('%command' => $command), WATCHDOG_ERROR, '/admin/settings/kboo/episode');
    }
  }
}

/**
 * Move audio files and attach to nodes
 *
 * @param $episode_audiofile = object - record from kboo_episode_audio_files
 */
function schedule_episode_attach_audio($episode_audiofile){
  global $user;
  $user = user_load(1);
  $episode = node_load($episode_audiofile->episode_id);
  $file_source = $episode_audiofile->filepath .'/'. $episode_audiofile->filename;
  $file_destination  = file_create_path(variable_get('schedule_episode_record_destination', 'episode_audio'));
  //file_move should update $file_source to new location
  if(file_exists($file_source) && file_check_directory($file_destination, $mode = FILE_CREATE_DIRECTORY)){
    if(file_move($file_source, $file_destination, FILE_EXISTS_RENAME)){
      // Create file object and update files table
      $audio_file = new stdClass();
      $audio_file->filename  = basename($file_source);
      $audio_file->filepath  = $file_source;
      $audio_file->filemime  = mime_content_type($file_source);
      $audio_file->filesize  = filesize($file_source);
      $audio_file->uid       = 1;
      $audio_file->timestamp = time();

      //$file_source is 0 if failed, otherwise gives new path
      if($file_source){
        drupal_write_record('files', $audio_file);
        file_set_status($audio_file, 0);
        $episode->field_episode_audio[0] = field_file_load($file_source);
        node_save($episode);
        //update kboo_schedule_episode_files record
        $sql = "UPDATE {kboo_schedule_episode_files} SET fid = %d, filepath = '%s', filename = '%s', updated = %d, status = %d WHERE episode_id = %d;";
        db_query($sql, $audio_file->fid, dirname($file_source), basename($file_source), time(), EPISODE_STATUS_ACTIVE, $episode->nid);
        $vars = array(
                      '%fid' => $audio_file->fid,
                      '%fname' => basename($file_source),
                      '%nid' => $episode->nid
                      );
        watchdog("schedule_episode", "File %fid (%fname) attached to node %nid", $vars, WATCHDOG_INFO);
      }
    }
    else{
      watchdog("schedule_episode", "Could not move: %source to %destination", array('%source' => $file_source, '%destination' => $file_destination), WATCHDOG_ERROR);
    }
  }
}

/**
 * delete audio files
 */
function schedule_episode_delete_audio($episode_audiofile){
  global $user;
  $user = user_load(1);

  $episode = node_load($episode_audiofile->episode_id);
  //check to see if audio file has changed
  if($episode_audiofile->fid == $episode->field_episode_audio[0]['fid']){
    $file_source = $episode_audiofile->filepath .'/'. $episode_audiofile->filename;
    $file_destination = variable_get('schedule_episode_record_remove', '') .'/'. $episode_audiofile->filename;
    unset($episode->field_episode_audio[0]);
    node_save($episode);
    watchdog("schedule_episode", "Removed: %fid - %file", array('%fid' => $episode_audiofile->fid, '%file' => $episode_audiofile->filename), WATCHDOG_INFO);
  }
  else{
    watchdog("schedule_episode", "User changed or removed: %fid - %file", array('%fid' => $episode_audiofile->fid, '%file' => $episode_audiofile->filename), WATCHDOG_INFO);
  }

  //update kboo_schedule_episode_files record
  $sql = "UPDATE {kboo_schedule_episode_files} SET updated = %d, status = %d WHERE episode_id = %d;";
  db_query($sql, time(), EPISODE_STATUS_DELETED, $episode_audiofile->episode_id);
}

/**
 * merged view for programs
 */
//function schedule_episode_views_query_alter(&$view, &$query){